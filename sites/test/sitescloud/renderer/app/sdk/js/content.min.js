/**
 * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at http://oss.oracle.com/licenses/upl.
 */
!function(e, t) {"function" == typeof define && define.amd ? define(["exports"], t) : "object" == typeof exports && exports && "string" != typeof exports.nodeName ? t(exports) : (e.contentSDK = {}, t(e.contentSDK))}(this, function(e) {"use strict";var t, n, o = function(e, t) {return function() {return e.apply(t, arguments)}}, r = function(e, t) {for (var n in t)t.hasOwnProperty(n) && (e[n] = t[n]);return e}, s = (n = function(e) {}, (t = {logLevel:"none", logLevels:["error", "warn", "info", "debug", "log"]}).updateLogger = function(e) {if (e) for (var r = 0;r < this.logLevels.length;r++) {var s = t.logLevels[r];t[s] = "function" == typeof e[s] ? o(e[s], e) : n}}, t.updateLogger({}), t), a = {requirePaths:{}, getContentLayoutRequirePath:function(e) {var t = e.contentServer, n = "object" == typeof e.cacheBuster ? e.cacheBuster : {layoutKey:e.cacheBuster, systemKey:e.cacheBuster}, o = n.layoutKey ? "/" + n.layoutKey : "", r = n.systemKey ? "/" + n.systemKey : "";if (!this.requirePaths[t]) {var s = "contentLayoutPath" + Math.floor(1e8 + 9e8 * Math.random()), a = {};a[s + "published"] = t + "/_compdelivery" + o, a[s + "draft"] = t + "/_themes/_components" + o, a[s + "system"] = t + "/_sitescloud" + r + "/sitebuilder/contentlayouts", this.requirePaths[t] = s, requirejs.config({paths:a})} return this.requirePaths[t]}, preloadContentLayout:function(e, t, n) {require([e], function(e) {t()}, function(t) {s.warn("ContentClient.renderLayout: Unable to render the layout.  Ensure you can access the layout: If running against published content, that the layout has been published. If draft, that you are logged onto the Sites server"), n("Failed to get layout: " + e + " with error: " + t)})}, renderContentLayout:function(e, t, n, o, r) {require([e], function(e) {var s = new e(t).render(n);"object" == typeof s && "function" == typeof s.then ? s.then(function(e) {o()}, function(e) {r(e)}) : o()}, function(t) {s.warn("ContentClient.renderLayout: Unable to render the layout.  Ensure you can access the layout: If published, that the layout has been published. If draft, that you are logged onto the Sites server"), r("failed to get layout: " + e + " with error: " + t)})}}, i = function() {};i.prototype = {type:"Node", extractServer:function(e) {var t = e || "http://localhost", n = require("url").parse(t);return n.protocol + "//" + n.hostname + (n.port ? ":" + n.port : "")}, callRestServer:function(e, t) {var n = this;s.debug("_rest.callRestServer: Calling " + t.method + " request with:"), s.debug(e), s.debug(t);var o = {"http:":require("http"), "https:":require("https")}, r = require("url");require("querystring");return new Promise(function(n, s) {var a, i = r.parse(e), u = o[i.protocol || "https:"], c = function(e) {try {return "function" == typeof t.beforeSend && t.beforeSend(e), !0} catch (e) {s({status:e, statusText:"Error in beforeSend() callback"})} return !1}, l = function(e) {var t = "", o = e.statusCode;e.on("data", function(e) {t += e}), e.on("end", function() {if (o >= 200 && o < 300) try {var r = JSON.parse(t);n(r)} catch (e) {s({error:t})} else s(e)})};if (i.method = t.method.toUpperCase() || "", "GET" === i.method && e)c(i) && (a = u.get(i, l));else if ("POST" === i.method && t.noCSRFToken && t.postData) {var p = JSON.stringify(t.postData);i.headers = {"Content-Type":"application/json", "X-Requested-With":"XMLHttpRequest", "Content-Length":p.length}, c(i) && (a = u.request(i, l).write(p))} else s({error:"unsupported REST request: " + JSON.stringify(t)});a && (a.on("error", function(e) {s({error:e})}), a.on("socket", function(e) {e.setTimeout(t.timeout), e.on("timeout", function() {s({error:"request timed out after: " + t.timeout})})}))}).then(function(e) {return "function" == typeof n.coerceData ? n.coerceData(e) : Promise.resolve(e)})}};var u = function() {};u.prototype = {type:"Browser", extractServer:function(e) {var t = e || window.location && window.location.href, n = document.createElement("a");return n.href = t, n.protocol + "//" + n.hostname + (n.port ? ":" + n.port : "")}, callRestServer:function(e, t) {var n = this;return s.debug("_rest.callRestServer: Calling " + t.method + " request with:"), s.debug(t), new Promise(function(n, o) {var r = new XMLHttpRequest, a = {method:t.method && t.method.toUpperCase() || "", url:e, timeout:t.timeout}, i = !0;if (t.authorization && ("published" === t.contentType && -1 !== ["session", "anonymous"].indexOf(t.authorization) || (a.headers = {Authorization:t.authorization})), "GET" === a.method && a.url || ("POST" === a.method && a.url && t.noCSRFToken && t.postData ? (a.headers["Content-Type"] = "application/json; charset=UTF-8", a.headers["X-Requested-With"] = "XMLHttpRequest", a.data = t.postData) : -1 !== ["POST", "PUT"].indexOf(a.method) && a.url && t.postData ? (a.headers["Content-Type"] = "application/json; charset=UTF-8", a.headers["X-Requested-With"] = "XMLHttpRequest", a.headers["X-CSRF-Token"] = this.getCSRFToken(a.url), a.data = t.postData) : "DELETE" === a.method && a.url ? a.headers["X-CSRF-Token"] = this.getCSRFToken(a.url) : (s.error("_rest.callRestServer: invalid arguments:"), s.error(t), o({status:400, statusText:'Expected to see arguments: { "method": "GET/POST/PUT/DELETE", "url": url } but recieved: ' + JSON.stringify(t)}), i = !1)), i) {for (var u in r.onload = function() {this.status >= 200 && this.status < 300 ? n(JSON.parse(r.response ? r.response : r.responseText)) : o({status:this.status, statusText:r.statusText})}, r.onerror = function() {o({status:this.status, statusText:r.statusText})}, r.ontimeout = function() {o({status:this.status, statusText:r.statusText})}, r.open(a.method, a.url), a.headers)a.headers.hasOwnProperty(u) && r.setRequestHeader(u, a.headers[u]);r.timeout = a.timeout, function(e) {try {return "function" == typeof t.beforeSend && t.beforeSend(e), !0} catch (e) {o({status:e, statusText:"Error in beforeSend() callback"})} return !1}(r) && (a.data ? r.send(JSON.stringify(a.data)) : r.send())}}).then(function(e) {return "function" == typeof n.coerceData ? n.coerceData(e) : Promise.resolve(e)})}};var c = function() {};(c.prototype = Object.create(u.prototype)).contextRoot = "/content", c.prototype.defaultVersion = "v1", c.prototype.supportedVersions = [{semanticVersion:"1.0.0", contentVersion:"v1"}, {semanticVersion:"1.1.0", contentVersion:"v1.1"}], c.prototype.getContentVersion = function(e, t) {for (var n = /\s*((([<>]?=?)\s*(v)?([0-9]+)(\.([0-9]+))?(\.([0-9]+))?))\s*/g.exec(t || "0.0.0") || [], o = (n[5] || "0") + "." + (n[7] || "0") + "." + (n[9] || "0"), r = 0;r < this.supportedVersions.length;r++) if (this.supportedVersions[r].semanticVersion === o) return this.supportedVersions[r].contentVersion;return s.warn('Content SDK: "' + e + '" has unrecognized Content Version: "' + t + '" - defaulting to: version="' + this.defaultVersion + '". To avoid this message, use one of the supported versions when creating a content client: ' + JSON.stringify(this.sOupportedVersions)), this.defaultVersion}, c.prototype.state = {published:"published", draft:"management"}, c.prototype.getCSRFToken = function(e) {return "CSRFToken"}, c.prototype.createPrefix = function(e) {return e.contentServer + this.contextRoot + "/" + this.state[e.contentType] + "/api/" + this.contentVersion}, c.prototype.createSuffix = function(e) {var t = e.search || "", n = e.channelToken ? this.properties.tokenName + "=" + e.channelToken : "", o = "object" == typeof e.cacheBuster ? e.cacheBuster.contentKey : e.cacheBuster, r = o ? "cb=" + o : "", s = "";return s += t, s += (s && n ? "&" : "") + n, s += (s && r ? "&" : "") + r}, c.prototype.formatURL = function(e, t) {var n = this.createPrefix(t), o = this.createSuffix(t), r = n + e + (o ? (-1 === e.indexOf("?") ? "?" : "&") + o : "");return s.info(r), r}, c.prototype.resolveGetTypesPath = function(e) {return "/types"}, c.prototype.resolveGetTypePath = function(e) {return "/types/" + e.typeName}, c.prototype.makeGetFolderMetadataURL = function(e) {var t = e.contentServer + "/documents/web?IdcService=GET_METADATA&suppressHttpErrorCodes=1&items=fFolderGUID:" + e.folderGUID.join(",");return s.info(t), t}, c.prototype.getLayouts = function(e, t) {var n = this, r = n.formatURL(n.resolveGetTypesAggregatePath({types:e || []}), t);return new Promise(function(e, s) {n.callRestServer(r, t).then(o(function(r) {var a, i = {};r.externalFile ? (i[r.externalFile.folderId] = r.name, a = n.makeGetFolderMetadataURL({contentServer:t.contentServer, folderGUID:[r.externalFile.folderId]}), n.callRestServer(a, t).then(o(function(t) {var n, o, r, a, u, c = t && t.ResultSets && t.ResultSets.xCaasTypeCategoryLayoutMappingCollection, l = {};if (c) {a = c.fields, u = c.rows;for (var p = 0;p < a.length;p++)"xCaasCategoryName" === a[p].name ? n = p : "xCaasLayoutName" === a[p].name ? o = p : "dParentMetadataUnitID" === a[p].name && (r = p);u.forEach(function(e) {var t = i[e[r]];l[t] || (l[t] = {}), l[t][e[n]] = e[o]}), e(l)} else s(t.LocalData.StatusMessage)}, n), function(e, t) {s(t)})) : e(void 0)}, n), function(e, t) {s(t)})})}, c.prototype.isDigitalAsset = function(e) {return /^DigitalAsset_/i.test(e) || 36 === e.length && (/^CONT/.test(e) || /^CORE/.test(e))}, c.prototype.getRenditionURL = function(e, t, n) {var o = "";if (e) if (this.isDigitalAsset(e)) {var r, a, i = n.format, u = n.download, c = "object" == typeof n.cacheBuster ? n.cacheBuster.contentKey : n.cacheBuster, l = "?";a = n.secureContent ? this.properties.secureAssetURLName : this.properties.assetURLName, r = t || this.properties.digitalAssetDefault, o = this.createPrefix(n) + "/" + a + "/" + e + "/" + r, c && (o += l + "cb=" + c, l = "&"), i && (o += l + "format=" + i, l = "&"), u && (o += l + "download=true", l = "&"), "published" === n.contentType && n.channelToken && (o += l + this.properties.tokenName + "=" + n.channelToken, l = "&")} else o = n.contentServer + "/documents/file/" + e;return s.info(o), o}, c.prototype.makeQueryParameters = function(e) {var t = r({}, e), n = {postData:{}, getData:""}, o = "", s = t.search;if (delete t.ids, delete t.IDs, delete t.id, delete t.ID, delete t.itemGUID, delete t.itemGUIDs, delete t.timeout, delete t.search, delete t.types, delete t.beforeSend, delete t.contentType, delete t.language, JSON.stringify(t).length > 1800)n.method = "POST", n.postData = t;else {var a = "";for (var i in t) if (t.hasOwnProperty(i) && i === encodeURI(i)) {var u = t[i];if ("orderBy" === i && Array.isArray(u) && 1 === u.length) {var c = u[0].order && u[0].order.toLowerCase() || "", l = c ? ":" + ("des" === c ? "desc" : c) : "";u = u[0].name + l}"object" != typeof u && (o += a + i + "=" + encodeURI(u), a = "&")}o += s ? a + s : "", n.method = "GET", n.getData = o, n.useAggregate = t.itemDepth || t.expand} return n};var l = function() {};(l.prototype = Object.create(c.prototype)).contentVersion = "v1", l.prototype.properties = {tokenName:"access-token", digitalAssetDefault:"default", assetURLName:"digital-assets", secureAssetURLName:"secure-digital-assets"}, l.prototype.resolveGetItemListPath = function(e) {return "/items" + (e.useAggregate ? "/aggregate" : "") + (e.types ? "?field:type:equals=" + e.types : "")}, l.prototype.resolveGetItemPath = function(e) {return "/items/" + e.itemGUID + (e.useAggregate ? "/aggregate" : "")}, l.prototype.resolveSearchPath = function(e) {return "/items/queries"}, l.prototype.resolveGetTypesAggregatePath = function(e) {return "/aggregates/types" + (e.types.length > 0 ? "/" + e.types.join(",") : "")}, l.prototype.resolveGetBulkItemListPath = function(e) {return "/items/bulk" + (e.useAggregate ? "/aggregate" : "") + "?ids=" + e.itemGUIDs.join(",")};var p = function(e) {e && (this.requestedContentVersion = e)};(p.prototype = Object.create(l.prototype)).contentVersion = "v1.1", p.prototype.properties = {tokenName:"channelToken", digitalAssetDefault:"native", assetURLName:"assets", secureAssetURLName:"assets"}, p.prototype.resolveGetItemListPath = function(e) {var t = "/items", n = "?";return e.types && (t += n + "field:type:equals=" + e.types, n = "&"), e.useAggregate && (t += n + 'expand="all"', n = "&"), t}, p.prototype.resolveGetItemPath = function(e) {var t = e.language ? "/variations/language/" + e.language + "?fields=all" : "", n = t ? "&" : "?", o = e.useAggregate ? n + "expand=" + e.useAggregate : "";return "/items/" + e.itemGUID + t + o}, p.prototype.resolveSearchPath = function(e) {return "/items"}, p.prototype.resolveGetTypesAggregatePath = function(e) {return "/types" + (e.types.length > 0 ? "/" + e.types.join(",") : "")}, p.prototype.resolveGetBulkItemListPath = function(e) {var t = '(id eq "' + e.itemGUIDs.join('" or id eq "') + '")', n = e.language ? '(language eq "' + e.language + '")' : "";return "/items?q=" + (n ? "(" + t + " and " + n + ")" : t)}, p.prototype.coerceData = function(e) {var t = this;return new Promise(function(n, o) {return "v1" === t.requestedContentVersion && ("object" == typeof e.fields ? e.data || (e.data = e.fields) : Array.isArray(e.items) && e.items.forEach(function(e) {"object" != typeof e.fields || e.data || (e.data = e.fields)})), n(e)})};var h = function(e) {return "v1" === c.prototype.getContentVersion("ContentSDK create content client", e) ? new p("v1") : new p}, d = function(e) {this.restAPI = h(e.contentVersion), s.updateLogger(e.logger), this.info = {accessToken:e.channelToken || e.accessToken, channelToken:e.channelToken || e.accessToken, cacheBuster:e.cacheBuster, beforeSend:e.beforeSend, clientType:"delivery", contentServer:this.restAPI.extractServer(e.contentServer), contentType:"published", secureContent:e.secureContent || !1, timeout:e.timeout || 0, contentVersion:this.restAPI.requestedContentVersion || this.restAPI.contentVersion}, this.info.authorization = e.authorization, this.validContentTypes = ["published"], this.validLayoutTypes = this.validContentTypes, this.publicSDK = {getInfo:o(this.getInfo, this), getItem:o(this.getItem, this), getItems:o(this.getItems, this), searchItems:o(this.queryItems, this), queryItems:o(this.queryItems, this), getRenditionURL:o(this.getRenditionURL, this), getLayoutInfo:o(this.getLayoutInfo, this), loadContentLayout:o(this.loadContentLayout, this), renderItem:o(this.renderItem, this), expandMacros:o(this.expandMacros, this)}, s.debug("ContentClient.create: Content Info:"), s.debug(this.info)};d.prototype.resolveRESTArgs = function(e, t) {var n = this.restAPI.makeQueryParameters(t), o = r({}, this.info);return o.method = e, o.contentType = this.getContentType(t.contentType), o.authorization = this.getInfo().authorization, o.language = t.language, o.beforeSend = t.beforeSend || o.beforeSend, o.timeout = t.timeout || o.timeout, o.postData = n.postData, o.useAggregate = n.useAggregate, o.search = n.getData, t.format && (o.format = t.format), t.download && (o.download = t.download), "GET" === o.method && (o.method = n.method || o.method), o}, d.prototype.getContentType = function(e) {var t = "string" == typeof e && e.toLowerCase() || this.info.contentType;return -1 !== this.validContentTypes.indexOf(t) ? t : (s.warn("Invalid value for content type request: " + e + ". Allowed values are: " + JSON.stringify(this.validContentTypes) + ". Defaulting to: " + this.info.contentType), this.info.contentType)}, d.prototype.getLayoutType = function(e) {var t = "string" == typeof e && e.toLowerCase() || this.info.contentType;return -1 !== this.validLayoutTypes.indexOf(t) ? t : (s.warn("Invalid value for layout type request: " + e + ". Allowed values are: " + JSON.stringify(this.validLayoutTypes) + ". Defaulting to: " + this.info.contentType), this.info.contentType)}, d.prototype.renderLayout = function(e, t, n, o, s, i) {if (o)a.preloadContentLayout(e, s, i);else {var u = r({}, t);u.contentClient || (u.contentClient = this.publicSDK), a.renderContentLayout(e, u, n, s, i)}}, d.prototype.getInfo = function() {return r({}, this.info)}, d.prototype.getItem = function(e) {var t = e || {}, n = t.id || t.ID || t.itemGUID, o = this.resolveRESTArgs("GET", t), r = this.restAPI.formatURL(this.restAPI.resolveGetItemPath({itemGUID:n, useAggregate:o.useAggregate, language:e.language}), o);return this.restAPI.callRestServer(r, o)}, d.prototype.getItems = function(e) {var t, n = this, o = e || {}, a = o.ids || o.IDs || o.itemGUIDs, i = n.resolveRESTArgs("GET", o);if (s.debug("ContentClient.getItems: arguments"), s.debug(o), Array.isArray(a) && a.length > 0) {var u, c = a.length, l = [];return new Promise(function(e, s) {for (var p = 0;p < c;p += 10)u = a.slice(p, p + 10), t = n.restAPI.formatURL(n.restAPI.resolveGetBulkItemListPath({itemGUIDs:u, types:o.types, useAggregate:i.useAggregate, language:i.language}), i), l.push(n.restAPI.callRestServer(t, i));Promise.all(l).then(function(t) {var o = {items:[]};"v1" === n.info.contentVersion ? (o.items = {}, t.forEach(function(e) {e && e.items && (o.items = r(o.items, e.items))})) : t.forEach(function(e) {o.items = o.items.concat(e.items)}), e(o)}, function(e) {s(e)})})} return t = n.restAPI.formatURL(n.restAPI.resolveGetItemListPath({itemGUID:o.itemGUID, types:o.types, useAggregate:i.useAggregate}), i), n.restAPI.callRestServer(t, i)}, d.prototype.queryItems = function(e) {var t = e || {}, n = this.resolveRESTArgs("GET", t);s.debug("ContentClient.queryItems: arguments"), s.debug(t), n.noCSRFToken = !0;var o = this.restAPI.formatURL(this.restAPI.resolveSearchPath(), n);return this.restAPI.callRestServer(o, n)}, d.prototype.getRenditionURL = function(e) {var t = e || {}, n = t.id || t.ID || t.itemGUID, o = this.resolveRESTArgs("GET", t);return this.restAPI.getRenditionURL(n, t.type, o)}, d.prototype.getLayoutInfo = function(e) {var t, n, o = this, r = e || {}, i = ["system-default-layout", "system-tile-layout"].indexOf(r.layout) > -1;return new Promise(function(e, u) {if (r.layout) {i ? (t = "system", n = r.layout) : (t = o.getLayoutType(r.layoutType), n = r.layout + "/assets/render");var c = a.getContentLayoutRequirePath(o.info) + t + "/" + n;s.debug("ContentClient.getLayoutInfo: require path: " + c), require([c], function(o) {var a = o.prototype.contentVersion;a || (s.warn('Content Layout: "' + r.layout + '" does not have a contentVersion specified. Assuming data needs to be fetched in "v1.0" format for this Content Layout.  To avoid this message, add the prototype.contentVersion property to the Content Layout Factory object.'), a = "1.0.0"), e({name:r.layout, layoutFactory:n, layoutType:t, requirePath:c, contentVersion:a})})} else s.debug("ContentClient.getLayoutInfo: missing required parameters"), u("missing parameters in call to getLayoutInfo: " + JSON.stringify(r))})}, d.prototype.loadContentLayout = function(e) {var t, n, o = this, r = e || {}, i = ["system-default-layout", "system-tile-layout"].indexOf(r.layout) > -1;return new Promise(function(e, u) {if (r.layout) {i ? (t = "system", n = r.layout) : (t = o.getLayoutType(r.layoutType), n = r.layout + "/assets/render");var c = a.getContentLayoutRequirePath(o.info) + t + "/" + n;s.debug("ContentClient.renderItem: require path: " + c), require([c], function(t) {e(t)})} else s.debug("ContentClient.renderItem: missing required parameters"), u("missing parameters in call to renderLayout: " + JSON.stringify(r))})}, d.prototype.renderItem = function(e) {var t, n, o = this, r = e || {}, i = ["system-default-layout", "system-tile-layout"].indexOf(r.layout) > -1;return new Promise(function(e, u) {if (r.layout) {i ? (t = "system", n = r.layout) : (t = o.getLayoutType(r.layoutType), n = r.layout + "/assets/render");var c = a.getContentLayoutRequirePath(o.info) + t + "/" + n;s.debug("ContentClient.renderItem: require path: " + c), o.renderLayout(c, r.data, r.container, r.preloadLayout, e, u)} else s.debug("ContentClient.renderItem: missing required parameters"), u("missing parameters in call to renderLayout: " + JSON.stringify(r))})}, d.prototype.expandMacros = function(e) {var t = e || "";return s.log("expandMacros: beforeValue: " + e), [{name:"DIGITAL_ASSET", macro:/\[!--\$CEC_DIGITAL_ASSET--\]*(.*?) *\[\/!--\$CEC_DIGITAL_ASSET--\]/g, value:o(function(e, t) {var n, o = t, r = !1;return t.indexOf(",") && (o = (n = t.split(","))[0], r = "true" === n[1]), this.getRenditionURL({id:o, download:r})}, this)}, {name:"PAGE_LINK", macro:/\[!--\$SCS_PAGE--\]*(.*?) *\[\/!--\$SCS_PAGE--\]/g, value:o(function(e, t) {var n, o = window && window.SCSRenderAPI || {};if ("function" == typeof o.getPageLinkData) {var r = o.getPageLinkData(t);n = r && r.href} else "function" == typeof o.getPageLinkUrl && (n = o.getPageLinkUrl(t));return n || "#"}, this)}].forEach(function(e) {t = t.replace(e.macro, e.value)}), s.log("expandMacros: afterValue: " + t), t};var f = function(e) {this.restAPI = h(e.contentVersion), s.updateLogger(e.logger), this.info = {accessToken:e.channelToken || e.accessToken, channelToken:e.channelToken || e.accessToken, beforeSend:e.beforeSend, cacheBuster:e.cacheBuster, clientType:"preview", contentServer:this.restAPI.extractServer(e.contentServer), contentType:e.contentType && "published" === e.contentType.toLowerCase() ? "published" : "draft", secureContent:e.secureContent || !1, timeout:e.timeout || 0, contentVersion:this.restAPI.requestedContentVersion || this.restAPI.contentVersion}, this.info.authorization = e.authorization, this.validContentTypes = ["published", "draft"], this.validLayoutTypes = this.validContentTypes, this.publicSDK = {getInfo:o(this.getInfo, this), getItem:o(this.getItem, this), getItems:o(this.getItems, this), searchItems:o(this.queryItems, this), queryItems:o(this.queryItems, this), getRenditionURL:o(this.getRenditionURL, this), getLayoutInfo:o(this.getLayoutInfo, this), loadContentLayout:o(this.loadContentLayout, this), renderItem:o(this.renderItem, this), expandMacros:o(this.expandMacros, this), getTypes:o(this.getTypes, this), getType:o(this.getType, this), getCategoryToLayoutMapping:o(this.getCategoryToLayoutMapping, this)}, s.debug("ContentClient.create: Content Info:"), s.debug(this.info)};(f.prototype = Object.create(d.prototype)).getTypes = function(e) {var t = e || {}, n = this.resolveRESTArgs("GET", t);s.debug("ContentClient.getTypes: arguments"), s.debug(t);var o = this.restAPI.formatURL(this.restAPI.resolveGetTypesPath(), n);return this.restAPI.callRestServer(o, n)}, f.prototype.getType = function(e) {var t = e || {}, n = this.resolveRESTArgs("GET", t);s.debug("ContentClient.getType: arguments"), s.debug(t);var o = this.restAPI.formatURL(this.restAPI.resolveGetTypePath({typeName:t.typeName}), n);return this.restAPI.callRestServer(o, n)}, f.prototype.getCategoryToLayoutMapping = function(e) {var t = this, n = e || {}, o = n.types || [], r = t.resolveRESTArgs("GET", n);return new Promise(function(e, n) {t.restAPI.getLayouts(o, r).then(function(t) {e(t)}, function(e) {n("Failed to retrieve layouts from the content server. Verify that you can connect to the content server. " + e)})})};return e.enableLogging = function() {console.info("ContentSDK - enableLogging function obsolete, pass logger into the content client")}, e.userLogging = function(e) {console.info("ContentSDK - userLogging function deprecated, pass logger into the content client"), s.updateLogger(e)}, e.createDeliveryClient = function(e) {var t = new d("object" == typeof e ? e : {});return s.debug("ContentSDK.createDelivery: created new Content SDK client object:"), s.debug(t), t ? t.publicSDK : void 0}, e.createPreviewClient = function(e) {var t = new f("object" == typeof e ? e : {});return s.debug("ContentSDK.createPreviewClient: created new Content SDK client object:"), s.debug(t), t ? t.publicSDK : void 0}, e});
